    <!DOCTYPE html>
    <html lang="en">
      <head>
        <meta charset="utf-8" />
        <title>Cesium Viewer Example</title>
        <!-- Include CesiumJS from the Cesium CDN -->
        <script src="https://cesium.com/downloads/cesiumjs/releases/1.120/Build/Cesium/Cesium.js"></script>
        <link
          href="https://cesium.com/downloads/cesiumjs/releases/1.120/Build/Cesium/Widgets/widgets.css"
          rel="stylesheet"
        />
        <style>
          html,
          body,
          #cesiumContainer {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
          }
          /* Layer control panel */
          #layerControl {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(42, 42, 42, 0.8);
            padding: 10px;
            color: white;
            font-family: sans-serif;
            border-radius: 4px;
          }
          #layerControl label {
            display: block;
            margin-bottom: 5px;
          }
          /* Legend panel (we will create two legends via JS) */
          .legendPanel {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background-color: rgba(42, 42, 42, 0.8);
            padding: 10px;
            color: white;
            font-family: sans-serif;
            border-radius: 4px;
            max-width: 150px;
          }
          .legendPanel div {
            margin-bottom: 4px;
          }
          /* Update panel */
          #updatePanel {
            position: absolute;
            bottom: 120px;
            left: 10px;
            background-color: rgba(42, 42, 42, 0.8);
            padding: 10px;
            color: white;
            font-family: sans-serif;
            border-radius: 4px;
          }
          #updatePanel label {
            display: block;
            margin-bottom: 5px;
          }
          #updatePanel input[type="text"] {
            width: 160px;
            margin-bottom: 5px;
          }
          #updatePanel button {
            margin-top: 5px;
          }
        </style>
      </head>
      <body>
        <div id="cesiumContainer"></div>




        <script>


//Download CZML files

/**
 * Save a Cesium DataSource to a CZML file (basic exporter).
 * Supports: position (constant or sampled), point, polyline (constant positions), color/width.
 *
 * @param {Cesium.DataSource} dataSource
 * @param {string} [filename="export.czml"]
 * @param {Cesium.Viewer} [viewer]  // used to resolve currentTime for getValue(); optional but recommended
 */
async function saveDataSourceToCZML(dataSource, filename = "export.czml", viewer) {
  if (!dataSource) throw new Error("saveDataSourceToCZML: dataSource is required");
  const time = viewer?.clock?.currentTime;

  // --- helpers ---
  const toRgba = (c) => {
    if (!c) return undefined;
    // Cesium Color is 0..1 floats; CZML needs 0..255 integers
    const r = Math.round(c.red   * 255);
    const g = Math.round(c.green * 255);
    const b = Math.round(c.blue  * 255);
    const a = Math.round((c.alpha ?? 1) * 255);
    return [r, g, b, a];
  };

  const cartesianToCartoDegrees = (cart) => {
    const carto = Cesium.Cartographic.fromCartesian(cart);
    return [
      Cesium.Math.toDegrees(carto.longitude),
      Cesium.Math.toDegrees(carto.latitude),
      carto.height
    ];
  };

  // CZML "position" writer for common property types
  const writePositionProperty = (posProp) => {
    if (!posProp) return undefined;

    // ConstantPositionProperty or raw Cartesian3
    if (posProp instanceof Cesium.ConstantPositionProperty || posProp instanceof Cesium.ConstantProperty || posProp instanceof Cesium.Cartesian3) {
      const cart = posProp.getValue ? posProp.getValue(time) : posProp;
      if (!cart) return undefined;
      return { cartographicDegrees: cartesianToCartoDegrees(cart) };
    }

    // SampledPositionProperty
    if (posProp instanceof Cesium.SampledPositionProperty) {
      const times = posProp._times || [];
      if (!times.length) return undefined;

      const epoch = Cesium.JulianDate.toIso8601(times[0]); // CZML epoch
      const samples = [];
      for (let i = 0; i < times.length; i++) {
        const t = times[i];
        const seconds = Cesium.JulianDate.secondsDifference(t, times[0]);
        const cart = posProp.getValue(t);
        const [lon, lat, h] = cartesianToCartoDegrees(cart);
        samples.push(seconds, lon, lat, h);
      }
      return { cartographicDegrees: { epoch, number: samples } };
    }

    // CallbackProperty (evaluate at current time)
    if (posProp instanceof Cesium.CallbackProperty) {
      const cart = posProp.getValue(time);
      if (!cart) return undefined;
      return { cartographicDegrees: cartesianToCartoDegrees(cart) };
    }

    // Fallback: try getValue()
    if (typeof posProp.getValue === "function") {
      const cart = posProp.getValue(time);
      if (!cart) return undefined;
      return { cartographicDegrees: cartesianToCartoDegrees(cart) };
    }
    return undefined;
  };

  // CZML "positions" for polylines (array of Cartesian3 or a ConstantProperty holding that)
  const writePolylinePositions = (positionsProp) => {
    let arr = positionsProp;
    if (positionsProp?.getValue) arr = positionsProp.getValue(time);
    if (!Array.isArray(arr) || !arr.length) return undefined;
    const flat = [];
    for (const p of arr) {
      const [lon, lat, h] = cartesianToCartoDegrees(p);
      flat.push(lon, lat, h);
    }
    return { cartographicDegrees: flat };
  };

  const docPacket = {
    id: "document",
    version: "1.0",
    name: dataSource.name || "Export",
    // optional: clock can be added if you’re exporting sampled data across a range
  };

  const czml = [docPacket];

  const entities = dataSource?.entities?.values || [];
  for (const e of entities) {
    const pkt = { id: e.id };

    if (e.name) pkt.name = e.name;

    // availability (if defined)
    if (e.availability) {
      const intervalStr = e.availability.toString(); // Cesium TimeIntervalCollection -> ISO interval string(s)
      if (intervalStr) pkt.availability = intervalStr;
    }

    // position (for points/billboards/labels/or general position-bearing entities)
    if (e.position) {
      const pos = writePositionProperty(e.position);
      if (pos) pkt.position = pos;
    }

    // point
    if (e.point) {
      const point = {};
      if (e.point.pixelSize) {
        const size = e.point.pixelSize.getValue ? e.point.pixelSize.getValue(time) : e.point.pixelSize;
        if (size != null) point.pixelSize = size;
      }
      if (e.point.color) {
        const col = e.point.color.getValue ? e.point.color.getValue(time) : e.point.color;
        const rgba = toRgba(col);
        if (rgba) point.color = { rgba };
      }
      if (Object.keys(point).length) pkt.point = point;
    }

    // polyline
    if (e.polyline) {
      const polyline = {};
      const pos = writePolylinePositions(e.polyline.positions);
      if (pos) polyline.positions = pos;

      if (e.polyline.width) {
        const w = e.polyline.width.getValue ? e.polyline.width.getValue(time) : e.polyline.width;
        if (w != null) polyline.width = w;
      }

      // material: color only (simple case)
      const mat = e.polyline.material?.getValue ? e.polyline.material.getValue(time) : e.polyline.material;
      // solid color material
      if (mat?.color) {
        const rgba = toRgba(mat.color);
        if (rgba) polyline.material = { solidColor: { color: { rgba } } };
      } else if (mat?.solidColor?.color) {
        const colVal = mat.solidColor.color.getValue ? mat.solidColor.color.getValue(time) : mat.solidColor.color;
        const rgba = toRgba(colVal);
        if (rgba) polyline.material = { solidColor: { color: { rgba } } };
      }

      if (Object.keys(polyline).length) pkt.polyline = polyline;
    }

    // Only push if we captured something beyond id
    if (Object.keys(pkt).length > 1) czml.push(pkt);
  }

  // download
  const blob = new Blob([JSON.stringify(czml, null, 2)], { type: "application/json" });
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  URL.revokeObjectURL(a.href);
  a.remove();
}






// CesiumLayerPanel.js  — ESM module
// Minimal, robust layer panel for Cesium DataSources with single click delegation.

class CesiumLayerPanel {
  /**
   * @param {Cesium.Viewer} viewer
   * @param {Object} [opts]
   * @param {string|HTMLElement} [opts.panel]         Selector or element for the panel container (created if missing).
   * @param {string} [opts.listSelector]              Selector for the inner list (created if missing). Default '#dsList'.
   * @param {(src: any)=>boolean} [opts.filter]       Only show DataSources where filter(src) === true.
   * @param {string} [opts.title]                     Panel title. Default 'Data Sources'.
   */
  constructor(viewer, opts = {}) {
    if (!viewer) throw new Error('CesiumLayerPanel: viewer is required');
    this.viewer = viewer;

    // Options
    this.opts = {
      panel: '#controlPanel',
      listSelector: '#dsList',
      filter: null,              // e.g., (src) => src.__wedge === true
      title: 'Data Sources',
      ...opts,
    };

    // DOM
    this.panel = this._resolvePanel(this.opts.panel);
    this.list = this._resolveList(this.panel, this.opts.listSelector);

    // State
    this._idToSource = new Map();
    this._perSourceListeners = new Map(); // DataSource -> { onLoading, onChanged }
    this._uid = 0;
    this._renderScheduled = false;

    // Bind handlers so we can remove them later
    this._onPanelClick = this._onPanelClick.bind(this);
    this._onDataSourceAdded = this._onDataSourceAdded.bind(this);
    this._onDataSourceRemoved = this._onDataSourceRemoved.bind(this);

    // Wire events
    this.panel.addEventListener('click', this._onPanelClick);
    const coll = this.viewer.dataSources;
    coll.dataSourceAdded.addEventListener(this._onDataSourceAdded);
    coll.dataSourceRemoved.addEventListener(this._onDataSourceRemoved);

    // Attach listeners to existing sources (if any)
    for (let i = 0; i < coll.length; i++) {
      const src = coll.get(i);
      this._attachSourceListeners(src);
    }

    // Initial paint
    this._render();
  }

  /** Force a re-render of the panel. */
  refresh() { this._render(); }

// Public helper: all currently visible data sources (respects opts.filter)
getVisibleSources() {
  const out = [];
  const coll = this.viewer.dataSources;
  for (let i = 0; i < coll.length; i++) {
    const src = coll.get(i);
    if (typeof this.opts.filter === 'function' && !this.opts.filter(src)) continue;
    if (src && src.show !== false) out.push(src);
  }
  return out;
}

  /** Clean up all listeners and DOM references created by this panel. */
  destroy() {
    // Remove collection listeners
    const coll = this.viewer.dataSources;
    coll.dataSourceAdded.removeEventListener(this._onDataSourceAdded);
    coll.dataSourceRemoved.removeEventListener(this._onDataSourceRemoved);

    // Remove per-source listeners
    for (const [src, fns] of this._perSourceListeners.entries()) {
      if (fns.onLoading && src?.loadingEvent?.removeEventListener) {
        src.loadingEvent.removeEventListener(fns.onLoading);
      }
      if (fns.onChanged && src?.changedEvent?.removeEventListener) {
        src.changedEvent.removeEventListener(fns.onChanged);
      }
    }
    this._perSourceListeners.clear();

    // Remove panel listener (keep the element in DOM)
    this.panel.removeEventListener('click', this._onPanelClick);

    // Clear UI state maps
    this._idToSource.clear();
  }

  // -------------------- private helpers --------------------

  _resolvePanel(panelOpt) {
    let el = null;
    if (typeof panelOpt === 'string') el = document.querySelector(panelOpt);
    else if (panelOpt instanceof HTMLElement) el = panelOpt;

    if (!el) {
      el = document.createElement('div');
      el.id = 'controlPanel';
      Object.assign(el.style, {
        position: 'absolute',
        top: '10px',
        left: '10px',
        background: 'rgba(255,255,255,0.9)',
        padding: '10px',
        borderRadius: '6px',
        boxShadow: '0 2px 6px rgba(0,0,0,0.2)',
        fontFamily: 'system-ui, -apple-system, Segoe UI, Roboto, sans-serif',
        fontSize: '14px',
        zIndex: 1000,
      });
      const title = document.createElement('strong');
      title.textContent = this.opts.title || 'Data Sources';
      title.style.display = 'block';
      title.style.marginBottom = '8px';
      el.appendChild(title);
      document.body.appendChild(el);
    } else {
      // Update title if present, else add one
      const first = el.querySelector('strong');
      if (first) first.textContent = this.opts.title || 'Data Sources';
      else {
        const title = document.createElement('strong');
        title.textContent = this.opts.title || 'Data Sources';
        title.style.display = 'block';
        title.style.marginBottom = '8px';
        el.prepend(title);
      }
    }
    return el;
  }

  _resolveList(panel, listSelector) {
    const sel = listSelector || '#dsList';
    let list = panel.querySelector(sel);
    if (!list) {
      list = document.createElement('div');
      list.id = sel.startsWith('#') ? sel.slice(1) : sel;
      panel.appendChild(list);
    }
    return list;
  }

  _scheduleRender() {
    if (this._renderScheduled) return;
    this._renderScheduled = true;
    Promise.resolve().then(() => {
      this._renderScheduled = false;
      this._render();
    });
  }

  _render() {
    this._idToSource.clear();
    this.list.innerHTML = '';

    // Copy DataSourceCollection -> array
    const dsArray = [];
    const coll = this.viewer.dataSources;
    for (let i = 0; i < coll.length; i++) dsArray.push(coll.get(i));

    // Optional filter
    const filtered = typeof this.opts.filter === 'function'
      ? dsArray.filter(this.opts.filter)
      : dsArray;

    if (!filtered.length) {
      const empty = document.createElement('div');
      empty.textContent = 'No data sources loaded.';
      empty.style.opacity = '0.7';
      this.list.appendChild(empty);
      return;
    }

    const frag = document.createDocumentFragment();
    filtered.forEach((src, idx) => {
      const row = document.createElement('label');
      Object.assign(row.style, {
        display: 'flex',
        alignItems: 'center',
        gap: '8px',
        margin: '6px 0',
      });

      const cb = document.createElement('input');
      cb.type = 'checkbox';
      cb.checked = src.show !== false;
      const id = `ds-${++this._uid}`;
      cb.dataset.dsuid = id;
      cb.setAttribute('aria-label', 'toggle data source visibility');

      const name = document.createElement('span');
      name.textContent = (src?.name && String(src.name).trim())
        ? String(src.name).trim()
        : (src?.constructor?.name || 'DataSource') + ' ' + (idx + 1);

      row.style.opacity = src?.isLoading ? '0.5' : '1';
      row.appendChild(cb);
      row.appendChild(name);
      frag.appendChild(row);

      this._idToSource.set(id, src);
    });

    this.list.appendChild(frag);
  }

  _attachSourceListeners(src) {
    const fns = {};
    if (src?.loadingEvent?.addEventListener) {
      fns.onLoading = () => this._scheduleRender();
      src.loadingEvent.addEventListener(fns.onLoading);
    }
    if (src?.changedEvent?.addEventListener) {
      fns.onChanged = () => this._scheduleRender();
      src.changedEvent.addEventListener(fns.onChanged);
    }
    if (Object.keys(fns).length) {
      this._perSourceListeners.set(src, fns);
    }
  }

  _detachSourceListeners(src) {
    const fns = this._perSourceListeners.get(src);
    if (!fns) return;
    if (fns.onLoading && src?.loadingEvent?.removeEventListener) {
      src.loadingEvent.removeEventListener(fns.onLoading);
    }
    if (fns.onChanged && src?.changedEvent?.removeEventListener) {
      src.changedEvent.removeEventListener(fns.onChanged);
    }
    this._perSourceListeners.delete(src);
  }

  _onDataSourceAdded(collection, src) {
    this._attachSourceListeners(src);
    this._scheduleRender();
  }

  _onDataSourceRemoved(collection, src) {
    this._detachSourceListeners(src);
    this._scheduleRender();
  }

  _onPanelClick(evt) {
    const t = evt.target;
    if (!(t instanceof HTMLInputElement) || t.type !== 'checkbox') return;
    const id = t.dataset.dsuid;
    if (!id) return;
    const src = this._idToSource.get(id);
    if (!src) return;
    src.show = !!t.checked;
    this.viewer.scene.requestRender();
  }
}















// Set your Cesium Ion access token.
          Cesium.Ion.defaultAccessToken =
            'set your Cesium Ion access token';
          var qsoUrl = "";
          var newHeight = 22;
          // Initialize the Cesium Viewer.
          var viewer = new Cesium.Viewer('cesiumContainer', {
            terrain: Cesium.Terrain.fromWorldTerrain({
              requestVertexNormals: true
            })
          });
          //const panelCtl = attachDataSourceVisibilityPanel(viewer);
//const panelCtl = attachDataSourceVisibilityPanel(viewer, {
//  includeImagery: true,
//  includeTilesets: true
//});

  const panelCtl = new CesiumLayerPanel(viewer);

          viewer.scene.globe.enableLighting = true;
          var osm = new Cesium.OpenStreetMapImageryProvider({
            url: 'https://tile.openstreetmap.org'
          });
          viewer.imageryLayers.addImageryProvider(osm);

          async function loadTileset() {
            try {
              const tileset = await Cesium.Cesium3DTileset.fromIonAssetId(96188);
              viewer.scene.primitives.add(tileset);
            } catch (error) {
              console.log(`Error loading tileset: ${error}`);
            }
          }
          // Call the async function
          loadTileset();

          // Global base URL for the data service.
          var baseUrl = "../";

          // Define default SQL parameters (they will be overridden by user input)
          var defaultMinLat = 15;
          var defaultMaxLat = 52;
          var defaultMinLng = -130;
          var defaultMaxLng = -60;
          var defaultStartTs = '2025-02-14T00:25:00';
          var defaultEndTs = '2025-02-14T01:55:00';

          // Function to build a glotec SQL query (for the standard layer)
          function buildGlotecSQL(minLat, maxLat, minLng, maxLng, startTs, endTs) {
            var sql =
              "select " +
              "uid as Spotter, " +
              "timestamp, " +
              "longitude as tx_lng, " +
              "latitude as tx_lat, " +
              "hmF2 as dB, " +
              "hmF2*1000 as elev_tx, " +
              "hmF2 as edmaxalt, " +
              "1 as hmF2Map, " +
              "NmF2 " +
              "from glotec " +
              "where \"tx_lat\" > " +
              minLat +
              " " +
              "and \"tx_lat\" < " +
              maxLat +
              " " +
              "and \"tx_lng\" > " +
              minLng +
              " " +
              "and \"tx_lng\" < " +
              maxLng +
              " " +
              "and \"timestamp\" > '" +
              startTs +
              "' " +
              "and \"timestamp\" < '" +
              endTs +
              "' " +
              "and \"hmF2\" > 0 " +
              "order by elev_tx asc";
            return sql;
          }

          // Function to build a FOF2 SQL query (for the FOF2 layer)
          function buildFof2SQL(minLat, maxLat, minLng, maxLng, startTs, endTs) {
            var sql =
              "select " +
              "uid as Spotter, " +
              "timestamp, " +
              "longitude as tx_lng, " +
              "latitude as tx_lat, " +
              "(sqrt(NmF2/.0124))/1000 as fof2, " +
              "(sqrt(NmF2/.0124))/1000 as dB, " +
              "hmF2*1000 as elev_tx, " +
              "(sqrt(NmF2/.0124))/1000 as edmaxalt, " +
              "0 as hmF2Map, " +
              "NmF2 " +
              "from glotec " +
              "where \"tx_lat\" > " +
              minLat +
              " " +
              "and \"tx_lat\" < " +
              maxLat +
              " " +
              "and \"tx_lng\" > " +
              minLng +
              " " +
              "and \"tx_lng\" < " +
              maxLng +
              " " +
              "and \"timestamp\" > '" +
              startTs +
              "' " +
              "and \"timestamp\" < '" +
              endTs +
              "' " +
              "and NmF2 > 0 " + 
              "order by fof2 asc";
            return sql;
          }

          function build_pref2m_QSOSQL(minLat, maxLat, minLng, maxLng, startTs, endTs, elev) {
            var sql = `
SELECT 
  timestamp,
  strftime('%Y%m%d', timestamp) as date,
  strftime('%H%M', timestamp) as time,
  dB,
  tx_rst,
  tx_lat,
  Spotter,
  tx_lng,
  rx_lat,
  rx_lng,
  325 as ionosonde,
  '${elev}' as elev_tx,
  0 as hmF2Map,
  "US-4578" as park,
  'KD0FNR' as call,
  cast(f2m as integer) as f2m
from  rm_rnb_history_pres
WHERE timestamp BETWEEN '${startTs}' AND '${endTs}' AND dB > 100

            `;
          return sql;
          }


          function buildQSOSQL(minLat, maxLat, minLng, maxLng, startTs, endTs, elev) {
            var sql = `
WITH qso AS (
  SELECT *,
         midpoint_lat(tx_lat, tx_lng, rx_lat, rx_lng) as ap_lat,
         midpoint_lng(tx_lat, tx_lng, rx_lat, rx_lng) as ap_lng,  
         haversine(tx_lat, tx_lng, rx_lat, rx_lng) as length
  FROM [rm_toucans_slice].rm_rnb_history_pres
  WHERE timestamp BETWEEN '${startTs}' AND '${endTs}' AND dB > 100
),
f2 AS (
  SELECT *
  FROM [glotec_slice].glotec
  WHERE timestamp BETWEEN '${startTs}' AND '${endTs}'
)
SELECT 
  qso.timestamp,
  strftime('%Y%m%d', qso.timestamp) as date,
  strftime('%H%M', qso.timestamp) as time,
  dB,
  tx_rst,
  qso.tx_lat,
  qso.Spotter,
  qso.tx_lng,
  qso.rx_lat,
  qso.rx_lng,
  325 as ionosonde,
  '${elev}' as elev_tx,
  0 as hmF2Map,
  "US-4578" as park,
  'KD0FNR' as call,
  call,
  (
    SELECT max(f.hmF2)
    FROM f2 AS f
    WHERE f.latitude BETWEEN qso.ap_lat - 1.75 AND qso.ap_lat + 1.75
      AND f.longitude BETWEEN qso.ap_lng - 2.6 AND qso.ap_lng + 2.6
      AND (ABS(strftime('%s', f.timestamp) - strftime('%s', qso.timestamp)) / 60) < 6
  ) AS f2m
FROM qso
ORDER BY timestamp ASC;
`;
            return sql;
          }

          // Global data source variables so we can update them.
          var glotecDataSource;
          var fof2DataSource;
          var qsoDataSource; 
          var radinfSource;
          var sphere1;
          var sphere2;
          var sphere3;
          var wedge1, wwedge2, wedge3;

          // ------------------------------
          // Methods to compute min/max values
          // ------------------------------

          // For Glotec (hmF2 values are loaded as "dB")
    // For Glotec (hmF2): Parse the number after "hmF2" in the _description._value field.
    function getMaxHmF2() {
      if (!glotecDataSource) return null;
      let maxVal = -Infinity;
      glotecDataSource.entities.values.forEach(entity => {
        if (entity._description && entity._description._value) {
          // Regex to match "hmF2" followed by a number (which may include decimals)
          const match = /hmF2\s+([\d\.]+)/i.exec(entity._description._value);
          if (match && !isNaN(match[1])) {
            const value = parseFloat(match[1]);
            if (value > maxVal) {
              maxVal = value;
            }
          }
        }
      });
      console.log(`highest F2 : ${maxVal}`)
      return maxVal;
    }

    function getMinHmF2() {
      if (!glotecDataSource) return null;
      let minVal = Infinity;
      glotecDataSource.entities.values.forEach(entity => {
        if (entity._description && entity._description._value) {
          const match = /hmF2\s+([\d\.]+)/i.exec(entity._description._value);
          if (match && !isNaN(match[1])) {
            const value = parseFloat(match[1]);
            if (value < minVal) {
              minVal = value;
            }
          }
          else{
            console.log("no match hmF2")
            console.log(entity._description._value);
          }
        }
      });
      return minVal;
    }

    // For FOF2: Parse the number after "fof2" in the _description._value field.
    function getMaxFof2() {
      if (!fof2DataSource) return null;
      let maxVal = -Infinity;
      fof2DataSource.entities.values.forEach(entity => {
        if (entity._description && entity._description._value) {
          
          const match = /fof2\s+([\d\.]+)/i.exec(entity._description._value);
          if (match && !isNaN(match[1])) {
            const value = parseFloat(match[1]);
            if (value > maxVal) {
              maxVal = value;
            }
          }
          else{
            console.log(entity._description._value);
          }
        }
      });
      return maxVal;
    }

    function getMinFof2() {
      if (!fof2DataSource) return null;
      let minVal = Infinity;
      fof2DataSource.entities.values.forEach(entity => {
        if (entity._description && entity._description._value) {
          const match = /fof2\s+([\d\.]+)/i.exec(entity._description._value);
          if (match && !isNaN(match[1])) {
            const value = parseFloat(match[1]);
            if (value < minVal) {
              minVal = value;
            }
          }
        }
      });
      return minVal;
    }

          // ------------------------------
          // Legend builder function
          // ------------------------------
          // We'll use the same color scale for both legends.
          var colorScale = [
    { rgba: [0, 0, 0, 255] },
    { rgba: [165, 42, 42, 255] },
    { rgba: [255, 0, 0, 255] },
    { rgba: [255, 165, 0, 255] },
    { rgba: [255, 255, 0, 255] },
    { rgba: [0, 128, 0, 255] },
    { rgba: [0, 0, 255, 255] },
    { rgba: [238, 130, 238, 255] },
    { rgba: [128, 128, 128, 255] },
    { rgba: [255, 255, 255, 255] }
          ];

          // Create or update a legend panel based on given min, max, and title.
          function buildLegend(containerId, minVal, maxVal, title) {
            var container = document.getElementById(containerId);
            if (!container) {
              container = document.createElement("div");
              container.id = containerId;
              container.className = "legendPanel";
              // Positioning: we offset each legend so they don't overlap.
              if (containerId === "legendHmF2") {
                container.style.right = "10px";
                container.style.bottom = "10px";
              } else if (containerId === "legendFof2") {
                container.style.right = "180px";
                container.style.bottom = "10px";
              }
              document.body.appendChild(container);
            }
            // Clear previous legend content.
            container.innerHTML = "<strong>" + title + "</strong><br/>";
            var nColors = colorScale.length;
            var bucketSize = (maxVal - minVal) / nColors;
            for (var i = 0; i < nColors; i++) {
              var lowerBound = minVal + bucketSize * i;
              var upperBound = minVal + bucketSize * (i + 1);
              var rgba = colorScale[i].rgba;
              var cssColor =
                "rgba(" +
                rgba[0] +
                ", " +
                rgba[1] +
                ", " +
                rgba[2] +
                ", " +
                rgba[3] / 255 +
                ")";
              var row = document.createElement("div");
              row.style.display = "flex";
              row.style.alignItems = "center";
              row.style.marginBottom = "4px";
              var swatch = document.createElement("div");
              swatch.style.width = "20px";
              swatch.style.height = "20px";
              swatch.style.backgroundColor = cssColor;
              swatch.style.marginRight = "8px";
              var label = document.createElement("div");
              label.textContent =
                lowerBound.toFixed(1) + " - " + upperBound.toFixed(1);
              row.appendChild(swatch);
              row.appendChild(label);
              container.appendChild(row);
            }
          }

          // Update legends based on current checkbox selections and loaded data.
          function updateLegends() {
//            var glotecCheckbox = document.getElementById("toggleGlotec");
//            if (glotecCheckbox.checked && glotecDataSource) {
//              var minHmF2 = getMinHmF2();
//              var maxHmF2 = getMaxHmF2();
//              if (minHmF2 !== null && maxHmF2 !== null) {
//                buildLegend("legendHmF2", minHmF2, maxHmF2, "hmF2 Legend");
//                document.getElementById("legendHmF2").style.display = "block";
//              }
//            } else {
//              var legendHmF2 = document.getElementById("legendHmF2");
//              if (legendHmF2) legendHmF2.style.display = "none";
//            }
//
//            var fof2Checkbox = document.getElementById("toggleFof2");
//            if (fof2Checkbox.checked && fof2DataSource) {
//              var minFof2 = getMinFof2();
//              var maxFof2 = getMaxFof2();
//              if (minFof2 !== null && maxFof2 !== null) {
//                buildLegend("legendFof2", minFof2, maxFof2, "FOF2 Legend");
//                document.getElementById("legendFof2").style.display = "block";
//              }
//            } else {
//              var legendFof2 = document.getElementById("legendFof2");
//              if (legendFof2) legendFof2.style.display = "none";
//            }
          }

         // ------------------------------
         // Update the map link based on current input values.
         // ------------------------------
         function updateMapLink() {
           var minLat = document.getElementById("minLat").value;
           var maxLat = document.getElementById("maxLat").value;
           var minLng = document.getElementById("minLng").value;
           var maxLng = document.getElementById("maxLng").value;
           var startTs = document.getElementById("startTs").value;
           var endTs = document.getElementById("endTs").value;
         
           // Get the base URL (current page's URL without query parameters)
           var base = window.location.origin + window.location.pathname;
         
           // Build URL parameters with names matching the input IDs.
           var params = new URLSearchParams();
           params.set("minLat", minLat);
           params.set("maxLat", maxLat);
           params.set("minLng", minLng);
           params.set("maxLng", maxLng);
           params.set("startTs", startTs);
           params.set("endTs", endTs);
         
           // Create the full URL.
           var url = base + "?" + params.toString();
           mapLink.href = url;
         }

////////////////////////////////////////////////////
////////////Layer auto-panel
///////////////////////////////////////////////////
/**
 * Hook up an auto-updating, click-delegated control panel for Cesium DataSources.
 * - Re-renders when sources are added, removed, or finish loading.
 * - Single event listener handles all checkbox clicks (event delegation).
 *
 * @param {Cesium.Viewer} viewer
 * @param {Object} [opts]
 * @param {string|HTMLElement} [opts.panel="#controlPanel"] container element or selector
 * @param {string} [opts.listSelector="#dsList"] inner list container (created if absent)
 */

function attachDataSourceVisibilityPanel(viewer, opts = {}) {
  // ----- panel & list -----
  const panel = typeof opts.panel === 'string'
    ? (document.querySelector(opts.panel) || createDefaultPanel())
    : (opts.panel || createDefaultPanel());

  let list = panel.querySelector(opts.listSelector || '#dsList');
  if (!list) {
    list = document.createElement('div');
    list.id = (opts.listSelector || '#dsList').replace(/^#/, '');
    panel.appendChild(list);
  }

  // ----- state kept in scope BEFORE render() -----
  const idToSource = new Map();         // <-- ensure this exists before render()
  let uid = 0;
  const idFor = () => `ds-${++uid}`;

  let renderScheduled = false;
  const scheduleRender = () => {
    if (renderScheduled) return;
    renderScheduled = true;
    Promise.resolve().then(() => { render(); renderScheduled = false; });
  };

  // ----- render the checkbox list -----
  function render() {
    idToSource.clear();
    list.innerHTML = '';

    // DataSourceCollection does NOT have `.values`; iterate with length/get()
    const col = viewer.dataSources;
    const sources = [];
    for (let i = 0; i < col.length; i++) sources.push(col.get(i));

    if (!sources.length) {
      const empty = document.createElement('div');
      empty.textContent = 'No data sources loaded.';
      empty.style.opacity = '0.7';
      list.appendChild(empty);
      return;
    }

    const frag = document.createDocumentFragment();
    sources.forEach((src, idx) => {
      const row = document.createElement('label');
      row.style.display = 'flex';
      row.style.alignItems = 'center';
      row.style.gap = '8px';
      row.style.margin = '6px 0';

      const cb = document.createElement('input');
      cb.type = 'checkbox';
      cb.checked = src.show !== false;
      const id = idFor();
      cb.dataset.dsuid = id;
      cb.setAttribute('aria-label', 'toggle data source visibility');

      const name = document.createElement('span');
      name.textContent =
        (src?.name && src.name.trim()) ? src.name.trim()
        : (src?.constructor?.name || 'DataSource') + ' ' + (idx + 1);

      row.style.opacity = src?.isLoading ? '0.5' : '1';
      row.appendChild(cb);
      row.appendChild(name);
      frag.appendChild(row);

      idToSource.set(id, src);
    });

    list.appendChild(frag);
  }

  // ----- keep in sync with adds/removes/loads -----
  const collection = viewer.dataSources;

  collection.dataSourceAdded.addEventListener((_col, src) => {
    // re-render on add and when load state changes
    if (src?.loadingEvent?.addEventListener) {
      src.loadingEvent.addEventListener(() => scheduleRender());
    }
    if (src?.changedEvent?.addEventListener) {
      src.changedEvent.addEventListener(() => scheduleRender());
    }
    scheduleRender();
  });

  collection.dataSourceRemoved.addEventListener(() => scheduleRender());

  // initial paint
  render();

  // ----- single delegated click handler -----
  panel.addEventListener('click', (evt) => {
    const t = evt.target;
    if (!(t instanceof HTMLInputElement) || t.type !== 'checkbox') return;
    const src = idToSource.get(t.dataset.dsuid);
    if (src) {
      src.show = !!t.checked;
      viewer.scene.requestRender();
    }
  });

  // ----- helpers -----
  function createDefaultPanel() {
    const div = document.createElement('div');
    div.id = 'controlPanel';
    div.style.position = 'absolute';
    div.style.top = '10px';
    div.style.left = '10px';
    div.style.background = 'rgba(255,255,255,0.9)';
    div.style.padding = '10px';
    div.style.borderRadius = '6px';
    div.style.boxShadow = '0 2px 6px rgba(0,0,0,0.2)';
    div.style.fontFamily = 'system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
    div.style.fontSize = '14px';
    const title = document.createElement('strong');
    title.textContent = 'Data Sources';
    title.style.display = 'block';
    title.style.marginBottom = '8px';
    div.appendChild(title);
    const listDiv = document.createElement('div');
    listDiv.id = 'dsList';
    div.appendChild(listDiv);
    document.body.appendChild(div);
    return div;
  }

  return { refresh: () => render() };
}


// ---- usage example ----
// const viewer = new Cesium.Viewer("cesiumContainer", { terrain: Cesium.Terrain.fromWorldTerrain() });
// const panelCtl = attachDataSourceVisibilityPanel(viewer);
// (no further code changes needed — add/remove data sources freely)
//////////////////////////////////////////////////////////////
//////////////Layer auto panel
//////////////////////////////////////////////////////////////













          // ------------------------------
          // Function to load or update the CZML layers based on the given parameters.
          // ------------------------------
          function updateMap(minLat, maxLat, minLng, maxLng, startTs, endTs) {
            // Build SQL query strings and encode them.
            var glotecSQL = buildGlotecSQL(
              minLat,
              maxLat,
              minLng,
              maxLng,
              startTs,
              endTs
            );
            var fof2SQL = buildFof2SQL(
              minLat,
              maxLat,
              minLng,
              maxLng,
              startTs,
              endTs
            );
            var qsoSQL = build_pref2m_QSOSQL(
              minLat,
              maxLat,
              minLng,
              maxLng,
              startTs,
              endTs,
              newHeight
            );
            var glotecUrl = baseUrl + "glotec_slice.iczml?sql=" + encodeURIComponent(glotecSQL);
            var fof2Url = baseUrl + "glotec_slice.iczml?sql=" + encodeURIComponent(fof2SQL);
            qsoUrl = baseUrl + "rm_toucans_slice.czml?sql=" + encodeURIComponent(qsoSQL);  
            console.debug("hmF2 " + glotecUrl);
            console.debug("fof2Url" + fof2Url);
            console.debug("qsoUrl" + qsoUrl);
            // Remove existing glotec and fof2 data sources (if any).
            if (glotecDataSource) {
              viewer.dataSources.remove(glotecDataSource, true);
            }
            if (fof2DataSource) {
              viewer.dataSources.remove(fof2DataSource, true);
            }
            if(qsoDataSource){
              viewer.dataSources.remove(qsoDataSource, true);
            }

            // Load new data sources.
            Cesium.CzmlDataSource.load(glotecUrl).then(function (ds) {
              glotecDataSource = ds;
              //viewer.dataSources.add(glotecDataSource);
              // Once loaded, update the legends.
              updateLegends();
            });

            Cesium.CzmlDataSource.load(fof2Url).then(function (ds) {
              fof2DataSource = ds;
              //viewer.dataSources.add(fof2DataSource);
              updateLegends();
            });

            Cesium.CzmlDataSource.load("interference_200yd_overlay_a.czml").then(function (ds) {
              radinfSource = ds;
              viewer.dataSources.add(radinfSource);
              //updateLegends();
            });
            Cesium.CzmlDataSource.load("shell_wedge_MODELED_corrected_1000m.czml").then(function (ds) {
              sphere1 = ds;
              viewer.dataSources.add(sphere1);
              //updateLegends();
            });
            Cesium.CzmlDataSource.load("shell_wedge_MODELED_corrected_250m.czml").then(function (ds) {
              sphere2 = ds;
              viewer.dataSources.add(sphere2);
              //updateLegends();
            });
            Cesium.CzmlDataSource.load("shell_wedge_MODELED_corrected_500m.czml").then(function (ds) {
              sphere3 = ds;
              viewer.dataSources.add(sphere3);
              //updateLegends();
            });
            Cesium.CzmlDataSource.load("shell_wedge_315_200_250m.czml").then(function (ds) {
              wedge1 = ds;
              viewer.dataSources.add(wedge1);
              //updateLegends();
            });
            Cesium.CzmlDataSource.load("shell_wedge_315_200_500m.czml").then(function (ds) {
              wedge2 = ds;
              viewer.dataSources.add(wedge2);
              //updateLegends();
            });
            Cesium.CzmlDataSource.load("shell_wedge_315_200_1000m.czml").then(function (ds) {
              wedge3 = ds;
              viewer.dataSources.add(wedge3);
              //updateLegends();
            });
//Cesium.CzmlDataSource.load('one_maritime_plaza_outline.czml').then(ds => {
//  viewer.dataSources.add(ds);
//  viewer.zoomTo(ds);
//});
            // (The qsoDataSource remains unchanged.)
            //var qso_url =
            //  'https://raw.githubusercontent.com/hcarter333/rm-rbn-history/refs/heads/main/maps/025_02_16_US_4758_Pony_Express_Short.czml';
            //var qso_url = 
            //  'http://192.168.0.203/sam_datasette/_memory.czml?sql=WITH+qso+AS+%28%0D%0A++SELECT+*%2C%0D%0A++midpoint_lat%28tx_lat%2C+tx_lng%2C+rx_lat%2C+rx_lng%29+as+ap_lat%2C%0D%0A++midpoint_lng%28tx_lat%2C+tx_lng%2C+rx_lat%2C+rx_lng%29+as+ap_lng%2C++%0D%0A++haversine%28tx_lat%2C+tx_lng%2C+rx_lat%2C+rx_lng%29+as+length%0D%0A++FROM+%5Brm_toucans%5D.rm_rnb_history_pres%0D%0A++WHERE+timestamp+BETWEEN+%272025-02-18T00%3A00%3A00Z%27+AND+%272025-02-18T23%3A59%3A59Z%27+and+dB+%3E+100%0D%0A%29%2C%0D%0Af2+AS+%28%0D%0A++SELECT+*%0D%0A++FROM+%5Bglotec%5D.glotec%0D%0A++WHERE+timestamp+BETWEEN+%272025-02-18T00%3A00%3A00Z%27+AND+%272025-02-18T23%3A59%3A59Z%27%0D%0A%29%0D%0ASELECT+%0D%0A++qso.timestamp%2C%0D%0A++strftime%28%27%25Y%25m%25d%27%2C+qso.timestamp%29+as+date%2C%0D%0A++strftime%28%27%25H%25M%27%2C+qso.timestamp%29+as+time%2C%0D%0A++dB%2C%0D%0A++tx_rst%2C%0D%0A++qso.tx_lat%2C%0D%0A++qso.Spotter%2C%0D%0A++qso.tx_lng%2C%0D%0A++qso.rx_lat%2C%0D%0A++qso.rx_lng%2C%0D%0A++qso.ap_lat%2C%0D%0A++qso.ap_lng%2C%0D%0A++325+as+ionosonde%2C%0D%0A++65+as+elev_tx%2C%0D%0A++%22US-4578%22+as+park%2C%0D%0A++%27KD0FNR%27+as+call%2C%0D%0A++call%2C%0D%0A++%28%0D%0A++++SELECT+max%28f.hmF2%29%0D%0A++++FROM+f2+AS+f%0D%0A++++where%0D%0A++++++f.latitude+BETWEEN+%0D%0A+++++++++qso.ap_lat+-+1.5%0D%0A+++++++++AND+%0D%0A+++++++++qso.ap_lat+%2B+1.5%0D%0A++++++AND%0D%0A++++++f.longitude+BETWEEN+%0D%0A+++++++++qso.ap_lng+-+3%0D%0A+++++++++AND+%0D%0A+++++++++qso.ap_lng+%2B+3%0D%0A+++++and+%28ABS%28strftime%28%27%25s%27%2C+f.timestamp%29+-+strftime%28%27%25s%27%2C+qso.timestamp%29%29%2F60%29+%3C+6%0D%0A++%29+AS+f2m%0D%0A%0D%0AFROM+qso%3B%0D%0A';
            //var qso_url = 
            //  'http://192.168.0.203/sam_datasette/_memory.czml?sql=WITH+qso+AS+%28%0D%0A++SELECT+*%2C%0D%0A++midpoint_lat%28tx_lat%2C+tx_lng%2C+rx_lat%2C+rx_lng%29+as+ap_lat%2C%0D%0A++midpoint_lng%28tx_lat%2C+tx_lng%2C+rx_lat%2C+rx_lng%29+as+ap_lng%2C++%0D%0A++haversine%28tx_lat%2C+tx_lng%2C+rx_lat%2C+rx_lng%29+as+length%0D%0A++FROM+%5Brm_toucans%5D.rm_rnb_history_pres%0D%0A++WHERE+timestamp+BETWEEN+%272025-02-21T01%3A34%3A00Z%27+AND+%272025-02-21T01%3A46%3A00Z%27+and+dB+%3E+100%0D%0A%29%2C%0D%0Af2+AS+%28%0D%0A++SELECT+*%0D%0A++FROM+%5Bglotec%5D.glotec%0D%0A++WHERE+timestamp+BETWEEN+%272025-02-21T01%3A34%3A00Z%27+AND+%272025-02-21T01%3A46%3A00Z%27%0D%0A%29%0D%0ASELECT+%0D%0A++qso.timestamp%2C%0D%0A++strftime%28%27%25Y%25m%25d%27%2C+qso.timestamp%29+as+date%2C%0D%0A++strftime%28%27%25H%25M%27%2C+qso.timestamp%29+as+time%2C%0D%0A++dB%2C%0D%0A++tx_rst%2C%0D%0A++qso.tx_lat%2C%0D%0A++qso.Spotter%2C%0D%0A++qso.tx_lng%2C%0D%0A++qso.rx_lat%2C%0D%0A++qso.rx_lng%2C%0D%0A++325+as+ionosonde%2C%0D%0A++-5+as+elev_tx%2C%0D%0A++%22US-4578%22+as+park%2C%0D%0A++%27KD0FNR%27+as+call%2C%0D%0A++call%2C%0D%0A++%28%0D%0A++++SELECT+max%28f.hmF2%29%0D%0A++++FROM+f2+AS+f%0D%0A++++where%0D%0A++++++f.latitude+BETWEEN+%0D%0A+++++++++qso.ap_lat+-+3.5%0D%0A+++++++++AND+%0D%0A+++++++++qso.ap_lat+%2B+3.5%0D%0A++++++AND%0D%0A++++++f.longitude+BETWEEN+%0D%0A+++++++++qso.ap_lng+-+7%0D%0A+++++++++AND+%0D%0A+++++++++qso.ap_lng+%2B+7%0D%0A+++++and+%28ABS%28strftime%28%27%25s%27%2C+f.timestamp%29+-+strftime%28%27%25s%27%2C+qso.timestamp%29%29%2F60%29+%3C+11%0D%0A++%29+AS+f2m%0D%0A%0D%0AFROM+qso%3B%0D%0A'
            //var qso_url = 
            //  'http://192.168.0.203/sam_datasette/rm_toucans.czml?sql=select%0D%0A++rowid%2C%0D%0A++id%2C%0D%0A++tx_lng%2C%0D%0A++tx_lat%2C%0D%0A++rx_lng%2C%0D%0A++rx_lat%2C%0D%0A++timestamp%2C%0D%0A++strftime%28%27%25Y%25m%25d%27%2C+timestamp%29+as+date%2C%0D%0A++strftime%28%27%25H%25M%27%2C+timestamp%29+as+time%2C%0D%0A++dB%2C%0D%0A++frequency%2C%0D%0A++Spotter%2C%0D%0A++Country%2C%0D%0A++State%2C%0D%0A++County%2C%0D%0A++City%2C%0D%0A++QSL_Sent%2C%0D%0A++QSL_Rx%2C%0D%0A++QSL_link%2C%0D%0A++QSL_rx_link%2C%0D%0A++tx_rst%2C%0D%0A++325+as+ionosonde%2C%0D%0A++325+as+edmaxalt%2C%0D%0A++-5+as+elev_tx%2C%0D%0A++%22US-4571%22+as+park%2C%0D%0A++%27KD0FNR%27+as+call%2C%0D%0A++p2p_s2%2C%0D%0A++301+as+f2m%2C%0D%0A++call%0D%0Afrom%0D%0A++rm_rnb_history_pres%0D%0Awhere%0D%0A++timestamp+%3E+%272025-02-22%27%0D%0A++and+timestamp+%3C+%272025-02-23%27%0D%0Aorder+by%0D%0A++timestamp%0D%0A'
            //2025_02_24 Seden
            //var qso_url = 
            //  'http://192.168.0.203/sam_datasette/rm_toucans.czml?sql=select%0D%0A++rowid%2C%0D%0A++id%2C%0D%0A++tx_lng%2C%0D%0A++tx_lat%2C%0D%0A++rx_lng%2C%0D%0A++rx_lat%2C%0D%0A++timestamp%2C%0D%0A++strftime%28%27%25Y%25m%25d%27%2C+timestamp%29+as+date%2C%0D%0A++strftime%28%27%25H%25M%27%2C+timestamp%29+as+time%2C%0D%0A++dB%2C%0D%0A++frequency%2C%0D%0A++Spotter%2C%0D%0A++Country%2C%0D%0A++State%2C%0D%0A++County%2C%0D%0A++City%2C%0D%0A++QSL_Sent%2C%0D%0A++QSL_Rx%2C%0D%0A++QSL_link%2C%0D%0A++QSL_rx_link%2C%0D%0A++tx_rst%2C%0D%0A++325+as+ionosonde%2C%0D%0A++325+as+edmaxalt%2C%0D%0A++-5+as+elev_tx%2C%0D%0A++%22US-4571%22+as+park%2C%0D%0A++%27KD0FNR%27+as+call%2C%0D%0A++p2p_s2%2C%0D%0A++324+as+f2m%2C%0D%0A++call%0D%0Afrom%0D%0A++rm_rnb_history_pres%0D%0Awhere%0D%0A++dB+%3E100%0D%0A++and+timestamp+%3E+%272025-02-24%27%0D%0A++and+timestamp+%3C+%272025-02-25%27%0D%0Aorder+by%0D%0A++timestamp%0D%0A'
            //qso_url = 
            //  'http://192.168.0.203/sam_datasette/_memory.czml?sql=WITH+qso+AS+%28%0D%0A++SELECT+*%2C%0D%0A++midpoint_lat%28tx_lat%2C+tx_lng%2C+rx_lat%2C+rx_lng%29+as+ap_lat%2C%0D%0A++midpoint_lng%28tx_lat%2C+tx_lng%2C+rx_lat%2C+rx_lng%29+as+ap_lng%2C++%0D%0A++haversine%28tx_lat%2C+tx_lng%2C+rx_lat%2C+rx_lng%29+as+length%0D%0A++FROM+%5Brm_toucans%5D.rm_rnb_history_pres%0D%0A++WHERE+timestamp+BETWEEN+%272025-03-10T00%3A00%3A00Z%27+AND+%272025-03-10T23%3A59%3A59Z%27+%0D%0A%29%2C%0D%0Af2+AS+%28%0D%0A++SELECT+*%0D%0A++FROM+%5Bglotec%5D.glotec%0D%0A++WHERE+timestamp+BETWEEN+%272025-03-10T00%3A00%3A00Z%27+AND+%272025-03-10T23%3A59%3A59Z%27%0D%0A%29%0D%0ASELECT+%0D%0A++qso.timestamp%2C%0D%0A++strftime%28%27%25Y%25m%25d%27%2C+qso.timestamp%29+as+date%2C%0D%0A++strftime%28%27%25H%25M%27%2C+qso.timestamp%29+as+time%2C%0D%0A++dB%2C%0D%0A++tx_rst%2C%0D%0A++qso.tx_lat%2C%0D%0A++qso.Spotter%2C%0D%0A++qso.tx_lng%2C%0D%0A++qso.rx_lat%2C%0D%0A++qso.rx_lng%2C%0D%0A++325+as+ionosonde%2C%0D%0A++-5+as+elev_tx%2C%0D%0A++%22US-4578%22+as+park%2C%0D%0A++%27KD0FNR%27+as+call%2C%0D%0A++call%2C%0D%0A++%28%0D%0A++++SELECT+max%28f.hmF2%29%0D%0A++++FROM+f2+AS+f%0D%0A++++where%0D%0A++++++f.latitude+BETWEEN+%0D%0A+++++++++qso.ap_lat+-+3.5%0D%0A+++++++++AND+%0D%0A+++++++++qso.ap_lat+%2B+3.5%0D%0A++++++AND%0D%0A++++++f.longitude+BETWEEN+%0D%0A+++++++++qso.ap_lng+-+7%0D%0A+++++++++AND+%0D%0A+++++++++qso.ap_lng+%2B+7%0D%0A+++++and+%28ABS%28strftime%28%27%25s%27%2C+f.timestamp%29+-+strftime%28%27%25s%27%2C+qso.timestamp%29%29%2F60%29+%3C+11%0D%0A++%29+AS+f2m%0D%0A%0D%0AFROM+qso%3B%0D%0A'
            //qsoUrl = 'https://raw.githubusercontent.com/hcarter333/rm-rbn-history/refs/heads/main/maps/2025_04_05_simul_sota.czml';
            //qsoUrl = 'https://raw.githubusercontent.com/hcarter333/rm-rbn-history/refs/heads/main/maps/2025_04_03_angel_scoutI.czml';
              Cesium.CzmlDataSource.load(qsoUrl).then(function (ds) {
              qsoDataSource = ds;
              viewer.dataSources.add(qsoDataSource);
              });
          }

          //updateMap(
          //  defaultMinLat,
          //  defaultMaxLat,
          //  defaultMinLng,
          //  defaultMaxLng,
          //  defaultStartTs,
          //  defaultEndTs
          //);

          // Create a layer control panel with two checkboxes.
          var layerPanel = document.createElement("div");
          layerPanel.id = "layerControl";
          layerPanel.innerHTML =
            '<label><input id="toggleGlotec" type="checkbox" checked> Glotec Map</label>' +
            '<label><input id="toggleFof2" type="checkbox" checked> FOF2 Glotec Map</label>';
          //document.body.appendChild(layerPanel);

          //document.getElementById("toggleGlotec").addEventListener("change", function (e) {
          //  if (glotecDataSource) glotecDataSource.show = e.target.checked;
          //  updateLegends();
          //});
          //document.getElementById("toggleFof2").addEventListener("change", function (e) {
          //  if (fof2DataSource) fof2DataSource.show = e.target.checked;
          //  updateLegends();
          //});

          // Create a panel for inputting update parameters.
          var updatePanel = document.createElement("div");
          updatePanel.id = "updatePanel";
          updatePanel.innerHTML =
            '<label>Min Latitude: <input id="minLat" type="text" value="' +
            defaultMinLat +
            '"></label>' +
            '<label>Max Latitude: <input id="maxLat" type="text" value="' +
            defaultMaxLat +
            '"></label>' +
            '<label>Min Longitude: <input id="minLng" type="text" value="' +
            defaultMinLng +
            '"></label>' +
            '<label>Max Longitude: <input id="maxLng" type="text" value="' +
            defaultMaxLng +
            '"></label>' +
            '<label>Start Timestamp: <input id="startTs" type="text" value="' +
            defaultStartTs +
            '"></label>' +
            '<label>End Timestamp: <input id="endTs" type="text" value="' +
            defaultEndTs +
            '"></label>' +
            '<button id="updateBtn">Update Map</button>' + 
            '<button id="downloadQsoButton" >Download QSO CZML</button>';
          document.body.appendChild(updatePanel);


// --- Add QTH Elevation input and button ---
var qthDiv = document.createElement("div");
qthDiv.style.marginTop = "8px";
qthDiv.innerHTML =
  '<label style="display:inline-block; margin-right:4px;">' +
    'qth elevation: <input id="qthElev" type="text" value="0" style="width:60px;">' +
  '</label>' +
  '<button id="updateEle">update ele</button>';
updatePanel.appendChild(qthDiv);
var eleNowLabel = document.createElement("div");
eleNowLabel.id = "eleNow";
eleNowLabel.style.marginTop = "4px";
eleNowLabel.textContent = "ele now: ";
updatePanel.appendChild(eleNowLabel);




// --- Wire up the update elevation button ---
var fileHeight = "";
var fndFileHeight = 0;
var finalHeight = "";

// helper: return a new Cartesian3 with height + delta
function bumpHeight(cartesian, delta) {
  const c = Cesium.Cartographic.fromCartesian(cartesian);
  const newH = c.height + delta;
  return Cesium.Ellipsoid.WGS84.cartographicToCartesian(
    new Cesium.Cartographic(c.longitude, c.latitude, newH)
  );
}



document.getElementById("updateEle").addEventListener("click", function () {
  const delta = parseFloat(document.getElementById("qthElev").value);
  if (isNaN(delta)) {
    console.error("Invalid elevation offset");
    return;
  }

  // Prefer the panel’s visible list; otherwise fall back to scanning the viewer
  const visibleSources = (typeof layerPanel?.getVisibleSources === "function")
    ? layerPanel.getVisibleSources()
    : (() => {
        const out = [];
        const coll = viewer.dataSources;
        for (let i = 0; i < coll.length; i++) {
          const src = coll.get(i);
          if (src && src.show !== false) out.push(src);
        }
        return out;
      })();

  let lastNewHeight; // to update the "ele now" label

  let srcCnt = 0
  visibleSources.forEach((src) => {
    let entityCnt = 0;
    console.log("updating " + src)
    const entities = src?.entities?.values;
    if (!entities || !entities.length) return;
    console.log("source " + srcCnt);
    srcCnt++;
    entities.forEach((entity) => {
      //original F2 start adjustment
      if (
        (entity?.id?.includes("f2") &&
        !entity.id.includes("f2down") &&
        entity.polyline?.positions) || 
        (entity.polyline?.positions)
      ) {
        const positions = entity.polyline.positions.getValue(); // assumes Constant/Callback with no time needed
        if (!Array.isArray(positions) || positions.length === 0) return;

        const oldCarto = Cesium.Cartographic.fromCartesian(positions[0]);
        const newHeight = oldCarto.height + delta;

        // Preserve your existing globals/flags behavior
        if (typeof fndFileHeight !== "undefined" && fndFileHeight === 0) {
          window.fileHeight = oldCarto.height;
          window.fndFileHeight = 1;
        }

        const newCartesian = Cesium.Ellipsoid.WGS84.cartographicToCartesian(
          new Cesium.Cartographic(oldCarto.longitude, oldCarto.latitude, newHeight)
        );

        positions[0] = newCartesian;
        // Re-assign so Cesium picks up the change
        entity.polyline.positions = new Cesium.ConstantProperty(positions);

        lastNewHeight = newHeight;
      }
      //wedge adjustment
      if (
        (!entity?.id?.includes("f2") &&
        !entity.id.includes("f2down") &&
        entity.polyline?.positions)
      ) {
        // handle ConstantProperty / CallbackProperty / etc.
        const posVal = entity.polyline.positions.getValue();

        if (Array.isArray(posVal) && posVal.length) {
          // bump EVERY vertex
          const bumped = posVal.map(p => bumpHeight(p, delta));

          // optional: capture original height once
          if (typeof fndFileHeight !== "undefined" && fndFileHeight === 0) {
            const firstCarto = Cesium.Cartographic.fromCartesian(posVal[0]);
            window.fileHeight = firstCarto.height;
            window.fndFileHeight = 1;
          }

          // reassign so Cesium notices
          if (entity.polyline.positions instanceof Cesium.ConstantProperty) {
            entity.polyline.positions.setValue(bumped);
          } else {
            entity.polyline.positions = new Cesium.ConstantProperty(bumped);
          }

          lastNewHeight = Cesium.Cartographic.fromCartesian(bumped[0]).height;
        }
      }
    if(entity?.position){
        const oldCartop = Cesium.Cartographic.fromCartesian(entity.position.getValue());
        const newHeightp = oldCartop.height + delta;

        // Preserve your existing globals/flags behavior
        if (typeof fndFileHeight !== "undefined" && fndFileHeight === 0) {
          window.fileHeight = oldCarto.height;
          window.fndFileHeight = 1;
        }

        const newCartesian = Cesium.Ellipsoid.WGS84.cartographicToCartesian(
          new Cesium.Cartographic(oldCartop.longitude, oldCartop.latitude, newHeightp)
        );

        position = newCartesian;
        // Re-assign so Cesium picks up the change
        entity.position = new Cesium.ConstantProperty(position);

        lastNewHeight = newHeight;

    }
    });
  });

  if (lastNewHeight !== undefined) {
    document.getElementById("eleNow").textContent = "ele now: " + lastNewHeight + " m";
  }

  viewer.scene.requestRender();
});


document.getElementById('downloadQsoButton').addEventListener('click', async () => {
  try {
    // Fetch the original CZML text
    var minLat = parseFloat(document.getElementById("minLat").value);
    var maxLat = parseFloat(document.getElementById("maxLat").value);
    var minLng = parseFloat(document.getElementById("minLng").value);
    var maxLng = parseFloat(document.getElementById("maxLng").value);
    var startTs = document.getElementById("startTs").value;
    var endTs = document.getElementById("endTs").value;

    var qsoSQL = build_pref2m_QSOSQL(
      minLat,
      maxLat,
      minLng,
      maxLng,
      startTs,
      endTs,
      newHeight
    );
    qsoUrl = baseUrl + "rm_toucans_slice.czml?sql=" + encodeURIComponent(qsoSQL);

    // Fetch the CZML text
    // Create a link and click it to download
    const a = document.createElement('a');
    a.href = qsoUrl;
    a.download = 'qso.czml';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);

    // Release the object URL
    //URL.revokeObjectURL(blobUrl);
  } catch (e) {
    console.error('Failed to download QSO CZML:', e);
    alert('Error downloading QSO data: ' + e.message);
  }


  //Now, download all the other layers

  // Prefer the panel’s visible list; otherwise fall back to scanning the viewer
  const visibleSources = (typeof layerPanel?.getVisibleSources === "function")
    ? layerPanel.getVisibleSources()
    : (() => {
        const out = [];
        const coll = viewer.dataSources;
        for (let i = 0; i < coll.length; i++) {
          const src = coll.get(i);
          if (src && src.show !== false) out.push(src);
        }
        return out;
      })();


  visibleSources.forEach((src) => {
    srcName = src.name;
    saveDataSourceToCZML(src, srcName + ".czml", viewer);
  });
});




         // Create a link element for returning to the current map settings.
         var mapLink = document.createElement("a");
         mapLink.id = "mapLink";
         mapLink.textContent = "link to map";
         mapLink.style.display = "block";
         mapLink.style.marginTop = "5px";
         updatePanel.appendChild(mapLink);
         
         

          document.getElementById("updateBtn").addEventListener("click", function () {
            var minLat = parseFloat(document.getElementById("minLat").value);
            var maxLat = parseFloat(document.getElementById("maxLat").value);
            var minLng = parseFloat(document.getElementById("minLng").value);
            var maxLng = parseFloat(document.getElementById("maxLng").value);
            var startTs = document.getElementById("startTs").value;
            var endTs = document.getElementById("endTs").value;
            updateMap(minLat, maxLat, minLng, maxLng, startTs, endTs);
            updateMapLink();
          });

          function updateInputsFromParams(urlParams) {
            // For each input, if the URLSearchParams object has a value for that key, update the input's value.
            if (urlParams.has("minLat")) {
              document.getElementById("minLat").value = urlParams.get("minLat");
            }
            if (urlParams.has("maxLat")) {
              document.getElementById("maxLat").value = urlParams.get("maxLat");
            }
            if (urlParams.has("minLng")) {
              document.getElementById("minLng").value = urlParams.get("minLng");
            }
            if (urlParams.has("maxLng")) {
              document.getElementById("maxLng").value = urlParams.get("maxLng");
            }
            if (urlParams.has("startTs")) {
              document.getElementById("startTs").value = urlParams.get("startTs");
            }
            if (urlParams.has("endTs")) {
              document.getElementById("endTs").value = urlParams.get("endTs");
            }
          }


        window.addEventListener('load', function() {

          console.log("Page fully loaded");
          // If the url contains control panel parameters, initially load layers with those.
          var queryString = window.location.search;
          var urlParams = new URLSearchParams(queryString);
          console.log("MinLat is ", urlParams.toString());
          if(urlParams.has("minLat")){
            updateInputsFromParams(urlParams);
            console.log("minLat is ", urlParams.get("minLat"));
            updateMap(urlParams.get("minLat"), urlParams.get("maxLat"),
                      urlParams.get("minLng"),urlParams.get("maxLng"),
                      urlParams.get("startTs"), urlParams.get("endTs"));


          }
          const id = urlParams.get("id");
        });


/// Global flag for rectangle selection mode.
var rectangleSelectionEnabled = false;

// Create a toggle button for rectangle selection.
var toggleRectButton = document.createElement("button");
toggleRectButton.id = "toggleRectSelection";
toggleRectButton.textContent = "Enable Rectangle Selection";
toggleRectButton.style.position = "absolute";
toggleRectButton.style.top = "10px";
toggleRectButton.style.right = "10px";
toggleRectButton.style.zIndex = 1000;
document.body.appendChild(toggleRectButton);

// Toggle rectangle selection mode and update camera controls.
toggleRectButton.addEventListener("click", function () {
  rectangleSelectionEnabled = !rectangleSelectionEnabled;
  if (rectangleSelectionEnabled) {
    toggleRectButton.textContent = "Disable Rectangle Selection";
    // Disable camera movement so the map doesn't move.
    viewer.scene.screenSpaceCameraController.enableRotate = false;
    viewer.scene.screenSpaceCameraController.enableTranslate = false;
    viewer.scene.screenSpaceCameraController.enableZoom = false;
    viewer.scene.screenSpaceCameraController.enableTilt = false;
    viewer.scene.screenSpaceCameraController.enableLook = false;
  } else {
    toggleRectButton.textContent = "Enable Rectangle Selection";
    // Re-enable camera controls.
    viewer.scene.screenSpaceCameraController.enableRotate = true;
    viewer.scene.screenSpaceCameraController.enableTranslate = true;
    viewer.scene.screenSpaceCameraController.enableZoom = true;
    viewer.scene.screenSpaceCameraController.enableTilt = true;
    viewer.scene.screenSpaceCameraController.enableLook = true;
  }
});

// --- Rectangle Selection Code ---
var selectionDiv = document.createElement("div");
selectionDiv.style.position = "absolute";
selectionDiv.style.border = "2px dashed #fff";
selectionDiv.style.backgroundColor = "rgba(0, 150, 255, 0.2)";
selectionDiv.style.pointerEvents = "none";
selectionDiv.style.display = "none";
document.body.appendChild(selectionDiv);

var isSelecting = false;
var startPoint = null;
var endPoint = null;

var handler = new Cesium.ScreenSpaceEventHandler(viewer.canvas);

// LEFT_DOWN: start selection if rectangleSelectionEnabled is true.
handler.setInputAction(function (click) {
  if (!rectangleSelectionEnabled) return;
  isSelecting = true;
  startPoint = click.position;
  selectionDiv.style.left = startPoint.x + "px";
  selectionDiv.style.top = startPoint.y + "px";
  selectionDiv.style.width = "0px";
  selectionDiv.style.height = "0px";
  selectionDiv.style.display = "block";
}, Cesium.ScreenSpaceEventType.LEFT_DOWN);

// MOUSE_MOVE: update rectangle dimensions.
handler.setInputAction(function (movement) {
  if (!rectangleSelectionEnabled || !isSelecting) return;
  endPoint = movement.endPosition;
  var left = Math.min(startPoint.x, endPoint.x);
  var top = Math.min(startPoint.y, endPoint.y);
  var width = Math.abs(startPoint.x - endPoint.x);
  var height = Math.abs(startPoint.y - endPoint.y);
  selectionDiv.style.left = left + "px";
  selectionDiv.style.top = top + "px";
  selectionDiv.style.width = width + "px";
  selectionDiv.style.height = height + "px";
}, Cesium.ScreenSpaceEventType.MOUSE_MOVE);

// LEFT_UP: finish selection, update coordinate inputs, and trigger update.
handler.setInputAction(function (click) {
  if (!rectangleSelectionEnabled || !isSelecting) return;
  isSelecting = false;
  selectionDiv.style.display = "none";
  endPoint = click.position;
  
  var ellipsoid = viewer.scene.globe.ellipsoid;
  var cartesianStart = viewer.camera.pickEllipsoid(startPoint, ellipsoid);
  var cartesianEnd = viewer.camera.pickEllipsoid(endPoint, ellipsoid);
  
  if (cartesianStart && cartesianEnd) {
    var cartoStart = Cesium.Cartographic.fromCartesian(cartesianStart);
    var cartoEnd = Cesium.Cartographic.fromCartesian(cartesianEnd);
    
    // Convert using Cesium.Math.toDegrees.
    var startLat = Cesium.Math.toDegrees(cartoStart.latitude);
    var startLng = Cesium.Math.toDegrees(cartoStart.longitude);
    var endLat = Cesium.Math.toDegrees(cartoEnd.latitude);
    var endLng = Cesium.Math.toDegrees(cartoEnd.longitude);
    
    var minLat = Math.min(startLat, endLat);
    var maxLat = Math.max(startLat, endLat);
    var minLng = Math.min(startLng, endLng);
    var maxLng = Math.max(startLng, endLng);
    
    // Update the text input fields.
    document.getElementById("minLat").value = minLat.toFixed(4);
    document.getElementById("maxLat").value = maxLat.toFixed(4);
    document.getElementById("minLng").value = minLng.toFixed(4);
    document.getElementById("maxLng").value = maxLng.toFixed(4);
    
    // Trigger the update button click.
    document.getElementById("updateBtn").click();
  }
}, Cesium.ScreenSpaceEventType.LEFT_UP);



        </script>
      </body>
    </html>
